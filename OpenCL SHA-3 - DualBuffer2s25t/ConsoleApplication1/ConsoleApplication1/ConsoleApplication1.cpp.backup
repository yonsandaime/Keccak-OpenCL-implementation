// ConsoleApplication1.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <fstream>
#include <sstream> 
#include <chrono>
#include <thread>    
#include <string>

#define _CRT_SECURE_NO_WARNINGS

#define CL_HPP_TARGET_OPENCL_VERSION 200
#include <CL/cl2.hpp>
typedef char* string_t;
#define total 1600
#define rate 1088 
#define BUFFER_SIZE 400
#define rateBytes rate/8
#define rateBytesBuffer rateBytes*BUFFER_SIZE
#define LOGG true

#define totalBytes total/8 
#define message "The R points to resource, the id that specific part of the resources created. use of val because we don't want this object to be changed (constant value). Instead of using loops to see what everything is doing we make use of EventHandlers that will trigger when, what you defined, happens. This will then redirect them to a predefined function. This is written as bellow (e.g. button clicking)"

std::string readFile(const char* const szFilename)
{
    std::ifstream in(szFilename, std::ios::in | std::ios::binary);
    std::ostringstream contents;
    contents << in.rdbuf();
    return contents.str();
}

std::ofstream myfile;

void hostr(const char* const filename)
{
    for (int j = 0; j < 1; j++) {
    using namespace std::chrono; // nanoseconds, system_clock, seconds
    //std::cout << "Hello World!\n";
    //get all platforms (drivers)
    std::vector<cl::Platform> all_platforms;
    cl::Platform::get(&all_platforms);
    if (all_platforms.size() == 0) {
        std::cout << " No platforms found. Check OpenCL installation!\n";
        exit(1);
    }
    //std::cout << "platforms size: " << all_platforms.size() << "\n";
    for (int i = 0; i < all_platforms.size(); i++)
    {
        cl::Platform default_platform = all_platforms[i];
        std::cout << "Available platform: " << default_platform.getInfo<CL_PLATFORM_NAME>() << "\n";
    }
    auto platform = all_platforms.at(0);
    std::cout << "Using platform: " << platform.getInfo<CL_PLATFORM_NAME>() << "\n";
    std::vector<cl::Device> devices;
    platform.getDevices(CL_DEVICE_TYPE_GPU, &devices);

    auto device = devices.front();
    cl::Context context({ device });

    cl::Program::Sources sources;

    std::string kernel_code = readFile("sha3DualBuffer2s1t-25.cl");

    sources.push_back({ kernel_code.c_str(),kernel_code.length() });

    cl::Program program(context, sources);
    if (program.build({ device }) != CL_SUCCESS) {
        std::cout << " Error building: " << program.getBuildInfo<CL_PROGRAM_BUILD_LOG>(device) << "\n";
        exit(1);
    }

    std::cout << "Hashed file: " << filename << "\n";


    std::string message2 = readFile(filename);
    int sizeFichier = message2.length();
    int size = message2.length();
    unsigned char output[32] = { "" };

    cl::CommandQueue queue(context, device, CL_QUEUE_PROFILING_ENABLE);
    cl::CommandQueue queue1(context, device, CL_QUEUE_PROFILING_ENABLE);

    cl::Buffer buffer_Output(context, CL_MEM_READ_WRITE, sizeof(char) * 32);
    cl::Buffer buffer_Size(context, CL_MEM_READ_WRITE, sizeof(int));
    cl::Buffer buffer_Input1(context, CL_MEM_READ_WRITE, rateBytesBuffer);
    cl::Buffer buffer_Input2(context, CL_MEM_READ_WRITE, rateBytesBuffer);

    cl::Buffer buffer_keccakCounter(context, CL_MEM_READ_WRITE, sizeof(int));
    
    int keccakCounter = 0;

    auto start = std::chrono::steady_clock::now();

    int itter = 0;
    queue.enqueueWriteBuffer(itter ? buffer_Input2 : buffer_Input1, CL_TRUE, 0, size > rateBytesBuffer ? rateBytesBuffer : size, message2.substr(0, rateBytesBuffer).c_str());
    size -= rateBytesBuffer;
    double avg_time = 0;
    cl_ulong time_start, time_end;
    for (int offset = 0; size > 0; itter = !itter) {

        int sizewBytes = size + rateBytesBuffer;
        queue.enqueueWriteBuffer(buffer_Size, CL_TRUE, 0, sizeof(int), &sizewBytes);
        queue.enqueueWriteBuffer(buffer_keccakCounter, CL_TRUE, 0, sizeof(int), &keccakCounter);

        cl::Kernel kernelKeccak1 = cl::Kernel(program, "Keccak");
        kernelKeccak1.setArg(0, itter ? buffer_Input2 : buffer_Input1);
        kernelKeccak1.setArg(1, buffer_Size);
        kernelKeccak1.setArg(2, buffer_Output);
        kernelKeccak1.setArg(3, buffer_keccakCounter);

        cl::Event prof_event;

        cl::Event write_event;
        cl::vector<cl::Event> m_lastaccesses;
        m_lastaccesses.push_back(write_event);

        queue1.enqueueNDRangeKernel(kernelKeccak1, cl::NullRange, cl::NDRange(25), cl::NullRange, NULL, &prof_event);
        size -= rateBytesBuffer;
        offset += rateBytesBuffer;
        
        prof_event.wait();
        prof_event.getProfilingInfo(CL_PROFILING_COMMAND_QUEUED, &time_start);
        prof_event.getProfilingInfo(CL_PROFILING_COMMAND_END, &time_end);
        double runtime = (double)(time_end - time_start);

        double time = runtime / 1000000000;
        avg_time += time;

        queue.enqueueWriteBuffer(itter ? buffer_Input1 : buffer_Input2, CL_TRUE, 0, rateBytesBuffer, message2.substr(offset, offset + rateBytesBuffer).c_str(), NULL, &m_lastaccesses[0]);
        keccakCounter++;
        
        queue1.finish();
        cl::WaitForEvents(m_lastaccesses);
        std::cout << " keccakCounter: " << keccakCounter << "\r";
    }

    int sizewBytes = size + rateBytesBuffer;
    queue.enqueueWriteBuffer(buffer_Size, CL_TRUE, 0, sizeof(int), &sizewBytes);
    queue.enqueueWriteBuffer(buffer_keccakCounter, CL_TRUE, 0, sizeof(int), &keccakCounter);

    cl::Kernel kernelKeccak = cl::Kernel(program, "Keccak");
    kernelKeccak.setArg(0, itter ? buffer_Input2 : buffer_Input1);
    kernelKeccak.setArg(1, buffer_Size);
    kernelKeccak.setArg(2, buffer_Output);
    kernelKeccak.setArg(3, buffer_keccakCounter);

    cl::Event prof_event2;

    queue.enqueueNDRangeKernel(kernelKeccak, cl::NullRange, cl::NDRange(25), cl::NullRange, NULL, &prof_event2);

    prof_event2.wait();
    prof_event2.getProfilingInfo(CL_PROFILING_COMMAND_QUEUED, &time_start);
    prof_event2.getProfilingInfo(CL_PROFILING_COMMAND_END, &time_end);
    double runtime = (double)(time_end - time_start);

    double time = runtime / 1000000000;
    avg_time += time;

    queue.finish();
    queue1.finish();

    queue1.enqueueReadBuffer(buffer_Output, CL_TRUE, 0, sizeof(char) * 32, output);

    auto end = std::chrono::steady_clock::now();
    std::chrono::duration<double> elapsed_seconds = end - start;

    printf("\nHash Value : ");
    for (int i = 0; i < 32; i++)
        printf("%02x", output[i]);

    std::cout << "\nExecution time: " << avg_time;
    std::cout << "\n" << "Hashrate: " << (message2.length() / avg_time) << "\n\n\n";
    if (LOGG)myfile << filename << "; " << (message2.length() / avg_time) << "\n";
    }
}

int main()
{
    if (LOGG)myfile.open("loggerDualbuffer25Thread.csv");
    if (LOGG)myfile << "Dualbuffer25Thread" << "\n";

    /*hostr("1B.bin");
    hostr("10B.bin");
    hostr("100B.bin");

    hostr("1KB.bin");
    hostr("10KB.bin");
    hostr("100KB.bin");

    hostr("1MB.bin");
    hostr("10MB.bin");
    */

    hostr("100MB.bin");

    //hostr("scan carte grise.pdf");
    //hostr("test.pdf");

    if (LOGG)myfile << "\n";
    if (LOGG)myfile.close();
}